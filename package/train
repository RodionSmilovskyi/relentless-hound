#!/usr/bin/env python
# pylint: skip-file
import random
import sys
from itertools import count
import gym
import math
import os
import imageio
import pyvirtualdisplay

import torch.optim as optim
from collections import namedtuple, deque
from package.ppo import PPO
from package import settings
import argparse

import torch
import torch.nn as nn


from package.dqn import DQN
from package.replay_memory import ReplayMemory, Transition


BATCH_SIZE = 128
GAMMA = 0.99
EPS_START = 0.9
EPS_END = 0.05
EPS_DECAY = 1000
TAU = 0.005
LR = 1e-4

def train():
    """Main training method"""

    device = torch.device(
        "cuda"
        if torch.cuda.is_available() and settings.USE_GPU is True
        else "mps" if torch.backends.mps.is_available() else "cpu"
    )

    print(f"Used device {device.type}")

    env = gym.make(
        "Ant-v4",
        render_mode=(
            "human"
            if settings.RUN_IN_CONTAINER is False and settings.USE_GUI is True
            else "rgb_array"
        ),
    )

    with torch.device(device):
        model = PPO(env)

        if os.path.exists(
            f"{settings.CHECKPOINT_PATH}/ppo_actor.pth"
        ) and os.path.exists(f"{settings.CHECKPOINT_PATH}/ppo_critic.pth"):
            model.actor.load_state_dict(
                torch.load(
                    f"{settings.CHECKPOINT_PATH}/ppo_actor.pth", weights_only=True, map_location=device
                )
            )
            model.critic.load_state_dict(
                torch.load(
                    f"{settings.CHECKPOINT_PATH}/ppo_critic.pth", weights_only=True, map_location=device
                )
            )

            print("Restored from checkpoint")

        model.learn(settings.TOTAL_TIMESTEPS)

    print("Complete")


def print_settings():
    attributes = dir(settings)
    constants = [attr for attr in attributes if attr.isupper()]

    for constant in constants:
        print(f"{constant}: {getattr(settings, constant)}")


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--prefix", type=str, default=os.path.dirname(os.path.abspath(__file__))
    )
    parser.add_argument("--use-gui", action="store_true")
    parser.add_argument("--use-gpu", action="store_true")
    parser.add_argument("--use-noise", action="store_true")
    parser.add_argument("--use-lr-ann", action="store_true")
    parser.add_argument("--run-in-container", action="store_true")
    parser.add_argument("--total-timesteps", type=int, default=10000)
    parser.add_argument("--num-minibatches", type=int, default=5)
    parser.add_argument("--timesteps-per-batch", type=int, default=1000)
    parser.add_argument("--learn-rate", type=float, default=0.001)
    parser.add_argument("--entropy", type=float, default=0.02)

    args = parser.parse_args()

    settings.INPUT_PATH = os.path.join(args.prefix, "input", "data", "training")
    settings.OUTPUT_PATH = os.path.join(args.prefix, "output")
    settings.MODEL_PATH = os.path.join(args.prefix, "model")
    settings.CHECKPOINT_PATH = os.path.join(args.prefix, "checkpoints")
    settings.USE_GUI = args.use_gui
    settings.USE_GPU = args.use_gpu
    settings.USE_NOISE = args.use_noise
    settings.RUN_IN_CONTAINER = args.run_in_container
    settings.TOTAL_TIMESTEPS = args.total_timesteps
    settings.TIMESTEPS_PER_BATCH = args.timesteps_per_batch
    settings.LEARN_RATE = args.learn_rate
    settings.ENTROPY_COEF = args.entropy
    settings.NUM_MINIBATCHES = args.num_minibatches
    settings.USE_LR_ANN = args.use_lr_ann

    print_settings()

    if settings.RUN_IN_CONTAINER is True:
        display = pyvirtualdisplay.Display(visible=0, size=(800, 600)).start()

    if not os.path.exists(settings.MODEL_PATH):
        os.makedirs(settings.MODEL_PATH)

    if not os.path.exists(settings.CHECKPOINT_PATH):
        os.makedirs(settings.CHECKPOINT_PATH)

    train()

    print("SUCCESS")

    sys.exit(0)
